#![allow(unused)]
#![feature(proc_macro_hygiene, decl_macro)]

extern crate bitcoin;
extern crate secp256k1;
extern crate num_bigint;
extern crate mysql;
extern crate reqwest;

#[macro_use] extern crate serde_derive;

extern crate sha2;

use secp256k1::Secp256k1;
use bitcoin::util::address::Address;

pub mod db;
pub mod util;

use crate::db::*;
use crate::util::*;

use sha2::{Sha256, Digest};

use std::env;

 


/*

    CREATE TABLE `wallet`.`address_rust` ( 
      `id` INT NOT NULL AUTO_INCREMENT , 
      `wif` VARCHAR(200) NOT NULL , 
      `addr` VARCHAR(200) NOT NULL , 
      PRIMARY KEY (`id`)
    ) ENGINE = InnoDB;

*/


fn main() {
    //read_every_bit();
  // read_file();
  let args: Vec<String> = env::args().collect();
  let i: usize = args[1].parse().unwrap();

  read_by_range(i);
}

fn read_file() {
	use std::fs::File;
	use std::io::BufReader; 
	use std::io::BufRead;

	let pool = mysql::Pool::new("mysql://test:test@/wallet").unwrap();

	let file = File::open("C:/Users/HENDRY/Documents/numeros_primos/facebook-firstnames.txt").unwrap();
	let mut reader = BufReader::new(file);

    loop {
        let mut number_str = String::new();

        match reader.read_line(&mut number_str) {
            Ok(n) => {
            	if n == 0 { break; }

            	let mut hasher = Sha256::new();
            	let str_c = number_str.clone();

				// write input message
				hasher.input(&number_str.into_bytes());
				let result  = &hasher.result().to_vec();

				let str_hex = hex::encode(result);
				println!("{:} => {:}", str_c, &str_hex);

			    let mut big_int = str_to_big(str_hex, 16u32);
			    call(&big_int, &mut pool.get_conn().unwrap().unwrap());  
			        	
            },
            Err(e) => {  }
        }

    }

}

/*
	0  => 80  :  36326929956805080917198740394882480895143524600985274992771006747580589690960 - 36326929956805080917198740394882480895143524600985274992771006747580589692676
	1  => 90  :  40867796201405716031848582944242791007036465176108434366867382591028163402330 - 40867796201405716031848582944242791007036465176108434366867382591028163404021
	2  => 100 :  45408662446006351146498425493603101118929405751231593740963758434475737113700 - 45408662446006351146498425493603101118929405751231593740963758434475737116020
	3  => 110 :  49949528690606986261148268042963411230822346326354753115060134277923310825070 - 45408662446006351146498425493603101118929405751231593740963758434475737145263
	4  => 120 :  54490394935207621375798110592323721342715286901477912489156510121370884536440 - 45408662446006351146498425493603101118929405751231593740963758434475737146525
	5  => 130 :  59031261179808256490447953141684031454608227476601071863252885964818458247810 - 59031261179808256490447953141684031454608227476601071863252885964818458250618
	6  => 140 :  63572127424408891605097795691044341566501168051724231237349261808266031959180 - 63572127424408891605097795691044341566501168051724231237349261808266031960898
	7  => 150 :  68112993669009526719747638240404651678394108626847390611445637651713605670550 - 68112993669009526719747638240404651678394108626847390611445637651713605671682
	8  => 160 :  72653859913610161834397480789764961790287049201970549985542013495161179381920 - 72653859913610161834397480789764961790287049201970549985542013495161179383074
	9  => 170 :  77194726158210796949047323339125271902179989777093709359638389338608753093290 - 77194726158210796949047323339125271902179989777093709359638389338608753094387
	10 => 180 :  81735592402811432063697165888485582014072930352216868733734765182056326804660 - 77194726158210796949047323339125271902179989777093709359638389338608753094388
	11 => 190 :  86276458647412067178347008437845892125965870927340028107831141025503900516030 - 81735592402811432063697165888485582014072930352216868733734765182056326806049
	12 => 200 :  90817324892012702292996850987206202237858811502463187481927516868951474227400 - 86276458647412067178347008437845892125965870927340028107831141025503900517313
	13 => 210 :  95358191136613337407646693536566512349751752077586346856023892712399047938770 - 90817324892012702292996850987206202237858811502463187481927516868951474227817
	14 => 220 :  99899057381213972522296536085926822461644692652709506230120268555846621650140
	15 => 230 :  104439923625814607636946378635287132573537633227832665604216644399294195361510
	16 => 240 :  108980789870415242751596221184647442685430573802955824978313020242741769072880
	17 => 245 :  111251222992715560308921142459327597741377044090517404665361208164465555928565
*/

fn read_by_range(i: usize){

	let list: Vec<String> = vec![ 
            "36326929956805080917198740394882480895143524600985274992771006747580589692676".to_owned(),
            "40867796201405716031848582944242791007036465176108434366867382591028163404021".to_owned(),
            "45408662446006351146498425493603101118929405751231593740963758434475737116020".to_owned(),
            "45408662446006351146498425493603101118929405751231593740963758434475737145263".to_owned(),
            "45408662446006351146498425493603101118929405751231593740963758434475737146525".to_owned(),
            "59031261179808256490447953141684031454608227476601071863252885964818458250618".to_owned(),
            "63572127424408891605097795691044341566501168051724231237349261808266031960898".to_owned(),
            "68112993669009526719747638240404651678394108626847390611445637651713605671682".to_owned(),
            "72653859913610161834397480789764961790287049201970549985542013495161179383074".to_owned(),
            "77194726158210796949047323339125271902179989777093709359638389338608753094387".to_owned(),
            "77194726158210796949047323339125271902179989777093709359638389338608753094388".to_owned(),
            "81735592402811432063697165888485582014072930352216868733734765182056326806049".to_owned(),
            "86276458647412067178347008437845892125965870927340028107831141025503900517313".to_owned(),
            "90817324892012702292996850987206202237858811502463187481927516868951474227817".to_owned(),
            "99899057381213972522296536085926822461644692652709506230120268555846621650140".to_owned(),
            "104439923625814607636946378635287132573537633227832665604216644399294195361510".to_owned(),
            "108980789870415242751596221184647442685430573802955824978313020242741769072880".to_owned(),
            "111251222992715560308921142459327597741377044090517404665361208164465555928565".to_owned()
	    ];
	
    let pool = mysql::Pool::new("mysql://test:test@/wallet").unwrap();

    let _str     = &list[i];
    let _str_end = &list[i+1];
	let mut big_int     = str_to_big(_str.to_string(), 10u32);
	let mut big_int_end = str_to_big(_str_end.to_string(), 10u32);

     
    while big_int < big_int_end { 
        println!("{:}", big_int.to_string());

        call(&big_int, &mut pool.get_conn().unwrap().unwrap());

		big_int = big_int + 1u64;
	}
}

fn read_every_bit(){
	
    let pool = mysql::Pool::new("mysql://test:test@/wallet").unwrap();

    let _str = "5653910607290829854666552002377339250647948470001980665989139844133934".to_owned();
	let mut big_int = str_to_big(_str, 16u32);

    let mut len = 233;
    while len > 230 { 
        println!("{:}", big_int.to_string());

        call(&big_int, &mut pool.get_conn().unwrap().unwrap());

		big_int = big_int - 1u64;
		len     = big_int.bits();
	}
}

fn call(big_int: &num_bigint::BigUint,  conn: &mut mysql::Conn) {
	let secp = Secp256k1::new();
	if let Some(pri_comp) =  private_from_big(&big_int, true) {
			 let pub_key = Address::p2pkh(&pri_comp.public_key(&secp), pri_comp.network);
			 if exist_address(conn, pub_key.to_string()) {
			 	store(conn, pri_comp.to_wif(), pub_key.to_string());
			    println!("priv: {:}, pub_key: {:}", pri_comp.to_wif(), pub_key);	 
			 }
			 let pub_key = Address::p2shwpkh(&pri_comp.public_key(&secp), pri_comp.network);
			 if exist_address(conn, pub_key.to_string()) {
			 	store(conn, pri_comp.to_wif(), pub_key.to_string());
			    println!("priv: {:}, pub_key: {:}", pri_comp.to_wif(), pub_key);	 
			 }	
			 
		};

		if let Some(pri_uncomp) =  private_from_big(&big_int, false) {
			let pub_key = Address::p2pkh(&pri_uncomp.public_key(&secp), pri_uncomp.network);
			if exist_address(conn, pub_key.to_string()) {
				store(conn, pri_uncomp.to_wif(), pub_key.to_string());
				println!("priv: {:}, pub_key: {:}", pri_uncomp.to_wif(), pub_key);
			}
			let pub_key = Address::p2shwpkh(&pri_uncomp.public_key(&secp), pri_uncomp.network);
			if exist_address(conn, pub_key.to_string()) {
				store(conn, pri_uncomp.to_wif(), pub_key.to_string());
				println!("priv: {:}, pub_key: {:}", pri_uncomp.to_wif(), pub_key);
			}
			
		};

}
